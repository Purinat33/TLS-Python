# Implementing TLS in Python Socket

Because a great way to learn is to make something yourself.

## Steps Taken

### 1. One-time CA & server setup (offline script)

A standalone script is run first to bootstrap trust material:

- Generate **Root CA** Ed25519 public/private key pair and save to files.
- Generate a **self-signed Root CA certificate** using the CA’s private key.
- Generate the **server’s** Ed25519 public/private key pair and save to files.
- Generate and sign the **server certificate** using the Root CA’s private key (the certificate’s `issuer` = Root CA, `subject` = server).

> This roughly corresponds to how a real PKI issues server certs, just with a single in-project Root CA.

---

### 2. What’s inside the certificates

Each X.509 certificate (Root CA, server) contains things like:

- **Subject Name** – who the certificate is about (e.g. the server).
- **Issuer Name** – who signed the certificate (Root CA for the server cert, itself for the Root CA).
- **Common Name (CN)** – the logical name we expect to connect to (e.g. `example-server`).
- **Serial Number** – unique identifier for the certificate.
- **Validity period** – `notBefore` and `notAfter` timestamps.
- The holder’s **public key**.
- A **digital signature** created with the issuer’s private key over the certificate’s TBSCertificate data.

> The client later checks this signature with the issuer’s **public key** to verify the certificate.

---

### 3–4. TCP connection

3. The **server** binds to an IP/port and starts listening.
4. The **client** connects to the server.

> At this point, you _could_ send data over the socket directly, but it would be unencrypted and unauthenticated. The rest of the steps build a secure channel on top.

---

### 5. ClientHello

5. The client sends a `ClientHello` message, which includes (in your minimal design):

- `ClientRandom` – 32 bytes of random data (hex-encoded).
- `EphPubKey` – the client’s **ephemeral X25519 public key** for this handshake.
- A protocol version and cipher suite indicator (e.g. `X25519`).
- The expected server name (like `example-server`).

This message is serialized as JSON + `\n` and sent over the socket.

---

### 6. Start the transcript hash

6. The client also initializes a **transcript hash** (SHA-256) and updates it with the exact bytes of the `ClientHello` line.

The server does the same when it receives the message. Both sides will:

- Maintain this running hash over all **handshake messages** (as raw bytes on the wire).
- Use it later for `CertificateVerify` and `Finished` messages to bind the handshake together.

---

### 7. ServerHello

7. The server receives `ClientHello`, updates its transcript hash, and sends back a `ServerHello` containing:

- `ServerRandom` – 32 bytes of server random.
- The server’s own **ephemeral X25519 public key** for this handshake.
- The chosen protocol version and cipher suite.

The client receives `ServerHello` and updates _its_ transcript hash with the same bytes.

---

### 8. Compute shared secret (X25519)

8. Using X25519:

- The **client** calls `client_ephemeral_private_key.exchange(server_eph_pub)`
- The **server** calls `server_ephemeral_private_key.exchange(client_eph_pub)`

Both compute the same **shared secret** value, thanks to the Diffie–Hellman property.

---

### 9. Derive handshake key with HKDF

9. From this shared secret, both sides derive a **handshake secret** using HKDF (with SHA-256 and a fixed `info` label like `b"Handshake Data"`).

This `derived_key` is then used as input to:

- Finished keys (for the `Finished` MACs), and
- Application traffic keys/IVs (for AES-GCM encrypted data).

---

### 10. Server sends certificate

10. The server sends its **X.509 certificate** to the client:

- Certificate is serialized to PEM.
- Then hex-encoded, wrapped in a JSON line, and sent.
- Both sides update the transcript hash with the certificate message bytes (as sent/received).

---

### 11. Client verifies server certificate against Root CA

11. The client parses the server certificate and checks:

- The certificate’s `issuer` matches the Root CA’s `subject`.
- The signature on the server certificate is valid using the **Root CA’s public key**.
- Optionally, that the certificate is within its validity period and the `Common Name` is what it expects.

If this passes, the server’s **public key** is trusted for this connection.

---

### 12. CertificateVerify (server proves it owns the cert key)

12. The server sends a `CertificateVerify` message:

- It takes a copy of the **current transcript hash** (up to and including the Certificate message).
- Signs that hash using its **identity private key** (the Ed25519 key corresponding to the server certificate).
- Sends the signature in a JSON line.
- Updates the transcript hash with the `CertificateVerify` message bytes.

This proves that the server not only presents a valid certificate, but also **controls the private key** and has seen this exact handshake transcript.

---

### 13. Client verifies CertificateVerify

13. The client:

- Copies its transcript hash (before adding `CertificateVerify`).
- Updates the transcript with the raw `CertificateVerify` bytes.
- Verifies the signature using the server’s **public key** from the server certificate.

If this check succeeds, the client knows:

- The server really owns the key in the cert, and
- The signature is bound to **this specific handshake** (ClientHello + ServerHello + Certificate).

---

### 14. Finished messages (mutual confirmation)

14. Both parties now compute and exchange `Finished` messages:

- Each side derives:

  - `finished_key_server = HKDF(..., info=b"server finished")`
  - `finished_key_client = HKDF(..., info=b"client finished")`

- The **server**:

  - Computes HMAC over its transcript hash (pre-Finished) with `finished_key_server`.
  - Sends the MAC as the **Server Finished** message.
  - Updates its transcript hash with the Finished bytes.

- The **client**:

  - Verifies this MAC using the same `finished_key_server` and its own pre-Finished transcript hash.
  - Then computes its own MAC using `finished_key_client` and its transcript hash (before Client Finished).
  - Sends the **Client Finished** message and updates its transcript hash.

- The **server** verifies the Client Finished MAC using `finished_key_client`.

At this point they’ve mutually confirmed:

- They derived the same secrets,
- They saw the same handshake transcript,
- And the server is authenticated.

---

### 15. Derive application keys & send encrypted data

15. With the handshake completed, both sides derive **application traffic keys** and IVs from the same `derived_key` using HKDF:

- `client_app_key`, `client_app_iv` for client→server traffic
- `server_app_key`, `server_app_iv` for server→client traffic

They then:

- Use a per-record sequence number and `IV XOR seq` style nonce (similar to TLS 1.3).
- Encrypt application messages with AES-GCM (or another AEAD), using the appropriate direction’s key+nonce.
- Serialize encrypted records as JSON lines containing:

  - `Seq` (sequence number)
  - `Ciphertext` (hex or base64)

- The server decrypts using the same key/IV/seq derivation and recovers the original plaintext.

The application data is now:

- Confidential (encrypted),
- Integrity-protected (AEAD tag),
- Bound to the authenticated handshake.

---

## To Run:

1. Run `certs.py` to generate the certificates.
2. Run `server.py` and `client.py` in separate terminals.

## Algorithms:

### 1. Public-key crypto

**a. Authentication / signatures**

- **Ed25519**

  - Used for:

    - Root CA key pair
    - Server identity key pair
    - Signing certificates (Root CA self-signed, CA → server cert)
    - `CertificateVerify` (server signs the transcript hash)

  - From: `cryptography.hazmat.primitives.asymmetric.ed25519`

**b. Key exchange**

- **X25519** (Elliptic-curve Diffie–Hellman over Curve25519)

  - Used for:

    - Ephemeral client key pair (`client_ephemeral_private_key`, `EphPubKey`)
    - Ephemeral server key pair
    - Computing the shared secret: `private.exchange(peer_public)`

  - From: `cryptography.hazmat.primitives.asymmetric.x25519`

---

### 2. Hashing & MAC

**a. Hash function**

- **SHA-256**

  - Used for:

    - Transcript hash (`hashlib.sha256()` on both sides)
    - HKDF’s underlying hash (`hashes.SHA256()` in the KDF)

  - Libraries:

    - `hashlib.sha256` (Python stdlib)
    - `cryptography.hazmat.primitives.hashes.SHA256`

**b. MAC (message authentication code)**

- **HMAC-SHA-256**

  - Used for:

    - `Finished` messages (server Finished, client Finished)
    - MAC over the transcript hash using `finished_key_server` / `finished_key_client`

  - From: `cryptography.hazmat.primitives.hmac.HMAC`

---

### 3. Key derivation

- **HKDF (HMAC-based Key Derivation Function) with SHA-256**

  - Used for:

    - Deriving the main handshake secret from the X25519 shared secret (`derived_key`)
    - Deriving `finished_key_server` and `finished_key_client`
    - Deriving application traffic keys:

      - `client_app_key`, `server_app_key`
      - `client_app_iv`, `server_app_iv`

  - From: `cryptography.hazmat.primitives.kdf.hkdf.HKDF`

---

### 4. Symmetric encryption (application data)

- **AES-GCM (AES in Galois/Counter Mode, AEAD)**

  - Key size: 32 bytes (so AES-256-GCM)
  - Nonce/IV: 12 bytes, constructed as `app_iv XOR seq_bytes`
  - Used for:

    - Encrypting client → server application data (`AESGCM(self.client_app_key)`)
    - (You could similarly use `server_app_key` for server → client)

  - From: `cryptography.hazmat.primitives.ciphers.aead.AESGCM`

---

### 5. Randomness

- **OS CSPRNG**

  - `os.urandom(32)` for:

    - `ClientRandom`
    - `ServerRandom`

  - Also used for random serial numbers / IDs in some places.

---

![alt text](TLS-Handshake-General-Steps-for-Establishing-a-TLS-Connection.jpg)

**Source**: [ResearchGate](https://www.google.com/url?sa=i&url=https%3A%2F%2Fwww.researchgate.net%2Ffigure%2FTLS-Handshake-General-Steps-for-Establishing-a-TLS-Connection_fig3_292995131&psig=AOvVaw3onDP6-OyC2hxJY-p0yJaY&ust=1764512487766000&source=images&cd=vfe&opi=89978449&ved=0CBgQjhxqFwoTCMidiLLHl5EDFQAAAAAdAAAAABBW)

**AI Disclosure**: The logical steps and some contents of README.md are consulted with the use of an LLM tool. No copy-paste-ready codes are generated or given to me at all throughout the development.

<!-- ## Steps Taken:

1. A standalone script must be ran to:
   - Generate Root CA public/private keys into files.
   - Generate and sign CA Certificate into a file using the CA's own private key.
   - Generate server's public/private keys into files.
   - Generate and sign the server's certificate with the Root CA's private key.
2. The certificates will contain:
   - Subject Name
   - Issuer Name
   - Common Name (What we are connecting to)
   - Serial Number
   - Period of Validity
   - The holder's **public key**
   - A unique signature created using the CA's private key
3. The server binds to an IP and port, and listens for a connection.
4. The client connects to the server.
   - Normally the client can start communicating with the server with only steps 3-4. But that is considered unsecured.
5. The client sends a `ClientHello` message, notable fields include:
   - `ClientRandom`: A random 32 bytes of message.
   - `EphPubKey`: The public key that the client generates a new pair of key (for this communication session only).
6. The client also hash the message into a **Transcript Hash**, both sides will maintain the same hash to ensure integrity. The hash will be continuously updated.
7. The server receives the `ClientHello` message, update its own transcript hash, and also sends back its own `ServerHello`
8. A shared secret message is computed between both parties.
9. A HKDF key is derived from this secret.
10. The server sends its own certificate to the client.
11. The client verify the certificate using the Root CA's **public key** (gotten from the Root CA's certificate).
12. The server also sends a `CertificateVerify` message, by signing the transcript hash up to that message.
13. The client verify the message using the server's **public key** (gotten from the server's certificate from the previous step).
14. Both parties compute finish messages.
15. Handshake step is now completed. Messages can be sent securely between both sides. -->
